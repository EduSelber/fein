<!DOCTYPE html>
<html lang="pt-br">

<head>
    <title>Floyd-Washall</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700;1,400;1,700&family=Open+Sans+Condensed:ital,wght@0,300;1,300&family=Open+Sans:ital,wght@0,300;0,400;0,700;0,800;1,300;1,400;1,700;1,800&family=Oxygen+Mono&family=Josefin+Sans:ital,wght@0,200;0,600;1,200;1,600&display=swap">
    <link rel="stylesheet" href="assets/css/reset.css">
    <link rel="stylesheet" href="assets/css/highlight.css">
    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/color.css">
    <!--<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>-->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script async src="https://static.codepen.io/assets/embed/ei.js"></script>
    <script src="assets/js/highlight.js"></script>
    <script src="assets/js/script.js"></script>
</head>

<body>
    <div class="container">
        <header>
            <a href="">abrir tudo</a>
            <a href="">fechar tudo</a>
        </header>
        <main>

            <h1>Floyd-Washall</h1>
<h2>Objetivo do código</h2>
<p>Este algoritimo tem o objetivo de encontrar todos os caminhos mais curtos entre os  vértices de um grafo</p>
<figure class="img"><img src="img/Grafo-Desprog.png" alt=""></figure>
<p>Este é um exemplo de grafo, esses grandes círculos são os vértices e as setas que ligam eles são as arestas. Os números em cima das arestas representam os pesos, ou seja, o quanto “custa” se deslocar de um vértice para o outro.
Você pode estar se perguntando “Para que esse algorítmo serve, afinal?”. Bem, se observar mais atentamente a figura, notará que nem todos os vértices desse grafo tem uma ligação direta entre eles. Seria impossível então se deslocar do vértice 1 até o 3? E se possível, qual o melhor “caminho” entre eles?</p>
<p>Pois bem, todas essas perguntas também são feitas quando estamos pensando em nos locomover de um ponto a outro da cidade. E, ao abrir o Google Maps, somos respondidos! Ele e outros softwares se utilizam do algoritmo de Floyd-Warshall para solucionar esses problemas. Devidamente motivados, vamos pensar mais no código em si.</p>
<h2>Quando se deve usar o algoritmo de Floyd-Warshall?</h2>
<p>O algoritmo é uma excelente escolha em situações específicas, como quando é necessário calcular o caminho mais curto entre todos os pares de nós em um grafo ponderado, ou seja em cenários que se exige calcular todas as distâncias de pares de vértices.</p>
<h2>Exercício 1</h2>
<h2>Simulando o codigo</h2>
<blockquote class="question">
<p>Atividade</p>
<p>No codigo é necessário criar <em>n</em> vértices auxiliar, como isso é feito.</p>
<details class="answer">
<summary>Gabarito</summary>
<p>Para fazer isso o código faz um loop de  <em>n</em> interações, que a cada interação cria um vértice auxiliar</p>
</details>
</blockquote>
<blockquote class="question">
<p>Atividade</p>
<p>Após criar o vértice auxiliar como faz para testar ele e verificar se com ele encontra um caminho mais curto usando ele.</p>
<details class="answer">
<summary>Gabarito</summary>
<p>Para fazer isso é necessário dois loops para percorrer a matriz e a cada interação verificar se usando o vértice auxiliar  o custo é melhorado, caso sim ele atualiza o valor na matriz para o do vértice auxiliar.</p>
</details>
</blockquote>
<p>Abaixo está o código de Floyd Washall , o qual contém 3 loops, que ajudarão a percorrer a matriz e encontrar os menores camninhos entre os vértices.</p>
<p>Aqui embaixo está o código de floyd washall</p>
<pre><code class="language-py">def floyd_warshall(graph):
    num_vertices = graph.shape[0]
    dist = graph.copy()
    iteracao = 0
    for k in range(num_vertices):
        for i in range(num_vertices):
            for j in range(num_vertices):
                if dist[i][j] &gt; dist[i][k] + dist[k][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]
                plot_and_save_matrix(dist, iteracao, i, j)
                iteracao += 1

    return dist
</code></pre>
<p>É importante comentar que a primeira linha do código armazena em uma variável local a quantidade total de vértices no grafo, o que é crucial para definir o número de iterações que cada loop deve executar.</p>
<p>Acompanhe pela animação, o que acontece com a matriz depois de cada interação do algoritimo</p>
<div class="animation"><img class="frame" src="img/Simulacao/distances01.png" alt="1"><img class="frame" src="img/Simulacao/distances02.png" alt="2"><img class="frame" src="img/Simulacao/distances03.png" alt="3"><img class="frame" src="img/Simulacao/distances04.png" alt="4"><img class="frame" src="img/Simulacao/distances05.png" alt="5"><img class="frame" src="img/Simulacao/distances06.png" alt="6"><img class="frame" src="img/Simulacao/distances07.png" alt="7"><img class="frame" src="img/Simulacao/distances08.png" alt="8"><img class="frame" src="img/Simulacao/distances09.png" alt="9"><img class="frame" src="img/Simulacao/distances10.png" alt="10"><img class="frame" src="img/Simulacao/distances11.png" alt="11"><img class="frame" src="img/Simulacao/distances12.png" alt="12"><img class="frame" src="img/Simulacao/distances13.png" alt="13"><img class="frame" src="img/Simulacao/distances14.png" alt="14"><img class="frame" src="img/Simulacao/distances15.png" alt="15"><img class="frame" src="img/Simulacao/distances16.png" alt="16"><img class="frame" src="img/Simulacao/distances17.png" alt="17"><img class="frame" src="img/Simulacao/distances18.png" alt="18"><img class="frame" src="img/Simulacao/distances19.png" alt="19"><img class="frame" src="img/Simulacao/distances20.png" alt="20"><img class="frame" src="img/Simulacao/distances21.png" alt="21"><img class="frame" src="img/Simulacao/distances22.png" alt="22"><img class="frame" src="img/Simulacao/distances23.png" alt="23"><img class="frame" src="img/Simulacao/distances24.png" alt="24"><img class="frame" src="img/Simulacao/distances25.png" alt="25"><img class="frame" src="img/Simulacao/distances26.png" alt="26"><img class="frame" src="img/Simulacao/distances27.png" alt="27"><img class="frame" src="img/Simulacao/distances28.png" alt="28"><img class="frame" src="img/Simulacao/distances29.png" alt="29"><img class="frame" src="img/Simulacao/distances30.png" alt="30"><img class="frame" src="img/Simulacao/distances31.png" alt="31"><img class="frame" src="img/Simulacao/distances32.png" alt="32"><img class="frame" src="img/Simulacao/distances33.png" alt="33"><img class="frame" src="img/Simulacao/distances34.png" alt="34"><img class="frame" src="img/Simulacao/distances35.png" alt="35"><img class="frame" src="img/Simulacao/distances36.png" alt="36"><img class="frame" src="img/Simulacao/distances37.png" alt="37"><img class="frame" src="img/Simulacao/distances38.png" alt="38"><img class="frame" src="img/Simulacao/distances39.png" alt="39"><img class="frame" src="img/Simulacao/distances40.png" alt="40"><img class="frame" src="img/Simulacao/distances41.png" alt="41"><img class="frame" src="img/Simulacao/distances42.png" alt="42"><img class="frame" src="img/Simulacao/distances43.png" alt="43"><img class="frame" src="img/Simulacao/distances44.png" alt="44"><img class="frame" src="img/Simulacao/distances45.png" alt="45"><img class="frame" src="img/Simulacao/distances46.png" alt="46"><img class="frame" src="img/Simulacao/distances47.png" alt="47"><img class="frame" src="img/Simulacao/distances48.png" alt="48"><img class="frame" src="img/Simulacao/distances49.png" alt="49"><img class="frame" src="img/Simulacao/distances50.png" alt="50"><img class="frame" src="img/Simulacao/distances51.png" alt="51"><img class="frame" src="img/Simulacao/distances52.png" alt="52"><img class="frame" src="img/Simulacao/distances53.png" alt="53"><img class="frame" src="img/Simulacao/distances54.png" alt="54"><img class="frame" src="img/Simulacao/distances55.png" alt="55"><img class="frame" src="img/Simulacao/distances56.png" alt="56"><img class="frame" src="img/Simulacao/distances57.png" alt="57"><img class="frame" src="img/Simulacao/distances58.png" alt="58"><img class="frame" src="img/Simulacao/distances59.png" alt="59"><img class="frame" src="img/Simulacao/distances60.png" alt="60"><img class="frame" src="img/Simulacao/distances61.png" alt="61"><img class="frame" src="img/Simulacao/distances62.png" alt="62"><img class="frame" src="img/Simulacao/distances63.png" alt="63"><img class="frame" src="img/Simulacao/distances64.png" alt="64"></div>
<blockquote class="warning">
<p>Aviso</p>
<p>Para o exercício abaixo é recomendado fazer passo a passo ao invés de tentar achar a resposta direto.</p>
</blockquote>
<blockquote class="question">
<p>Exercício</p>
<figure class="img"><img src="img/Matriz_incial.png" alt=""></figure>
<p>Tente simular o que acontecerá com está matriz depois de cada iteração do código.</p>
<details class="answer">
<summary>Gabarito</summary>
<figure class="img"><img src="img/Matriz_final.png" alt=""></figure>
<p>As alterações nessa matriz ocorreram nos vértices que não estavam conectado como, por exemplo, o caminho entre o vértice <em>1</em> e o <em>3</em>, que antes estava com um custo muito elevado, mas agora tem um custo três uma vez que foi usado vértice 2 como auxiliar.</p>
</details>
</blockquote>
<h2>Aplicações práticas em que o algoritmo deve ser usado</h2>
<p>Pense em um contexto de redes de transporte, em uma cidade com várias estações de ônibus ou metrô, cada uma conectada diferentes e diversas rotas específicas. O objetivo é determinar o tempo de viagem mais curto entre todas as estações, considerando todas as possíveis conexões diretas e indiretas.</p>
<p>Imagine uma cidade com 5 estações de ônibus, de A até E, com as seguintes conexões, diretas e indiretas, e pesos(tempos/distância).
Você foi designado a trabalhar na otimização dessa rede.</p>
<ul>
<li>A conecta com B em 4 minutos.</li>
<li>A conecta com D em 10 minutos.</li>
<li>B conecta com C em 5 minutos.</li>
<li>C conecta com B em 5 minutos.</li>
<li>D conecta com E em 15 minutos.</li>
<li>E conecta com B em 10 minutos.</li>
<li>C conecta com E em 7 minutos.</li>
</ul>
<blockquote class="question">
<p>Exercício: Modelando o problema</p>
<ol>
<li>Pense, quem será a rodoviária e o que o tempo representa no problema.</li>
</ol>
</blockquote>
<details class="answer">
<summary>Gabarito</summary>
<ul>
<li>Cada estação será um vértice no grafo;</li>
<li>Cada rota direta entre duas estações será uma aresta no grafo,  com peso correspondente ao tempo de viagem entre essas duas estações.</li>
</ul>
</details>
<blockquote class="question">
<p>Exercício: Implementando o algoritmo</p>
<ol start="2">
<li>Agora você vai implementar o algoritmo. Aplique a situação descrita na matriz inicial, nesse caso baseando nos tempos de viagem diretos entre as estações e se não houver conexão direta, o valor passa a ser infinito. Desenhe o grafo e depois implemente o algoritmo para obter o resultado de todos os pares da tabela.</li>
</ol>
</blockquote>
<details class="answer">
<summary>Gabarito</summary>
<pre><code class="language-c">void floydWarshall() {
int dist[V][V], i, j, k;

    // Inicializa a matriz de solução da mesma forma que a matriz de entrada do grafo
    for (i = 0; i &lt; V; i++)
        for (j = 0; j &lt; V; j++)
            dist[i][j] = graph[i][j];
 // Adiciona todos os vértices um por um ao conjunto de vértices intermediários.     
    for (k = 0; k &lt; V; k++) {
        // vértices como fonte
        for (i = 0; i &lt; V; i++) {
            // vértices como destino para a fonte escolhida
            for (j = 0; j &lt; V; j++) {

                if (dist[i][k] + dist[k][j] &lt; dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }
}
</code></pre>
</details>
<p>No final, você terá uma matriz de distâncias que fornecerá o tempo de viagem mais curto entre cada estação rodoviária.</p>
<h2>Complexidade do Algoritmo</h2>
<p>Agora nós já podemos supor como será a complexidade do algoritmo.</p>
<details class="answer">
<summary>Gabarito</summary>
<p>O algoritmo tem uma complexidade de O(n^3) . Lembre-se para cada dois vértices, existe uma iteração intermediária.</p>
</details>
<h2>Eficiência do Algoritmo</h2>
<p>E a eficiência do algoritmo?</p>
<details class="answer">
<summary>Gabarito</summary>
<p>A eficiência de memória será O(n^2), já que salvamos a matriz em uma última iteração e suas dimensões são n x n.</p>
</details>


        </main>
        <footer>
            <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank">
                <img alt="CC BY-SA 4.0" src="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" title="Creative Commons Attribution-ShareAlike 4.0 International License" />
            </a>
            © 2024 Marcelo Hashimoto
        </footer>
    </div>
</body>

</html>